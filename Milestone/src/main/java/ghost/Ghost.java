package ghost;
import java.util.ArrayList;
import java.util.Random;
import processing.core.PApplet;
import processing.core.PImage;
import processing.data.JSONArray;
import processing.core.PFont;
public class Ghost {
    protected int x;
    protected int y;
    protected int wakaX;
    protected int wakaY;
    protected PImage sprite;
    protected int speed;
    protected boolean scatter = true;
    protected int lastDirection = 0; //1 left 2 right 3 up 4 down
    protected boolean debug;
    protected boolean frightened;
    protected PImage frightenedImg;
    protected boolean sodaMode;
    protected PImage wavy1Img;
    protected PImage wavy2Img;
    protected String target;
    protected int sodaModePointer = 0;
    static protected int frightenedModeLength;
    static protected int frightenedModePointer = 0;
    static protected int modePointerI;
    static protected int modePointerJ;

    /**
     * Getter method for Ghost's x coordinate in unit of pixels.
     * @return x, x coordinate
     */
    public int getX() {
        return x;
    }

    /**
     * Getter method for Ghost's y coordinate in unit of pixels.
     * @return y, y coordinate
     */
    public int getY() {
        return y;
    }

    /**
     * Getter method for identity(type) of the ghost 
     * @return for generic ghost: null,
     *  for Ambusher: "Ambusher",
     *  for Chaser: "Chaser",
     *  for Ignorant: "Ignorant",
     *  for Whim: "Whim".
     */
    public String getIdentity() {
        return null;
    }

    /**
     * Getter method of sodaModePointer
     * @return int sodaModePointer
     */
    public int getSodaModePointer() { 
        return sodaModePointer;
    }

    /**
     * Getter method for modePointerI and modePointerJ.
     * modePointerI and modePointerJ are used for tracking
     * Ghost's time in modeLengths.
     * @return int[] {modePointerI,modePointerJ}
     */
    public static int[] getIJPointers() {
        return new int[] {modePointerI,modePointerJ};
    }

    /**
     * A static setter method which sets the frightened mode length
     * for the entire ghost class.
     * @param length specified in the config file.
     */
    public static void setFrightenedModeLength(int length) {
        Ghost.frightenedModeLength = length;
    }

    /**
     * Constructor for Ghost.
     */
    public Ghost(int x, int y, PImage sprite,PImage frightenedImg,PImage wavy1Img,PImage wavy2Img, int speed, int frightenedModeLength) {
        this.x = x;
        this.y = y;
        this.sprite = sprite;
        this.frightenedImg = frightenedImg;
        this.wavy1Img = wavy1Img;
        this.wavy2Img = wavy2Img;
        this.speed = speed;
    }

    /**
     * A stub constructor convenient for testing.
     */
    public Ghost(int x, int y, int speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
    }

    /**
     * @return Closest, a code range from 0 to 12,
     * representing different states of Ghost's 
     * motion relative to target position.
     */
    public int generateClosest(int targetX, int targetY) {
        int closest;
        if (targetX < x && targetY < y) { 
            if (x - targetX > y -targetY) {
                closest = 0;
            } else {
                closest = 9;
            }
        } else if (targetX > x && targetY < y) {
            if (targetX - x > y - targetY) {
                closest = 1;
            } else {
                closest = 10;
            }
        } else if (targetX < x && targetY > y) {
            if (x -targetX > targetY -y) {
                closest = 2;
            } else {
                closest = 11;
            }
        } else if (targetX > x && targetY > y) {
            if (targetX - x > targetY - y) {
                closest = 3;
            } else {
                closest = 12;
            }
        } else if (targetX == x && targetY < y) {
            closest = 4;
        } else if (targetX == x && targetY > y) {
            closest = 5;
        } else if (targetX < x && targetY == y) {
            closest = 6;
        } else if (targetX > x && targetY == y) {
            closest = 7;
        } else {
            closest = 8;
        }
        return closest;
    }

    /**
     * @param cellMap list of list of Cells.
     * @param closest code generated by generateClosest().
     * This method follows after the Closest code generated by generateClosest(),
     * Give Ghost with a given code a fixed pattern of movement.
     */
    public void moveAccordingToClosest(ArrayList<ArrayList<Cell>> cellMap, int closest) {
        if (closest == 0) {
            if (toLeft(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toRight(cellMap)) {
            } else {goBack();}
        } else if (closest == 1) {
            if (toRight(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else {goBack();}
        } else if (closest == 2) {
            if (toLeft(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toRight(cellMap)) {
            } else {goBack();}
            
        } else if (closest == 3) {
            if (toRight(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else {goBack();}
        } else if (closest == 4) {
            if (toUp(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toDown(cellMap)) {
            } else {goBack();}
        } else if (closest == 5) {
            if (toDown(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toUp(cellMap)) {
            } else {goBack();}
        } else if (closest == 6) {
            if (toLeft(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toDown(cellMap)){
            } else if (toRight(cellMap)) {
            } else {goBack();}
        } else if (closest == 7) {
            if (toRight(cellMap)) {}
            else if (toUp(cellMap)) {}
            else if (toDown(cellMap)) {}
            else if (toLeft(cellMap)) {}
            else {goBack();}
        } else if (closest == 9) {
            if (toUp(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toDown(cellMap)) {
            } else {goBack();}
        } else if (closest == 10) {
            if (toUp(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toDown(cellMap)) {
            } else {goBack();}
        } else if (closest == 11) {
            if (toDown(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toUp(cellMap)) {
            } else {goBack();}
        } else if (closest == 12) {
            if (toDown(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toUp(cellMap)) {
            } else {goBack();}
        }
    }

    /**
     * Setter method for I,J modePointers.
     * @param modePointerI: small increment pointer
     * @param modePointerJ: mode reverse pointer
     */
    public static void setIJPointers(int modePointerI, int modePointerJ) {
        Ghost.modePointerI = modePointerI;
        Ghost.modePointerJ = modePointerJ;
    }

    /**
     * A static method synchronises Waka and Ghost's frightened state.
     */
    public static void updateGhostFrightened(Waka waka) {
        Ghost.frightenedModePointer = waka.timeFrightened(Ghost.frightenedModeLength, frightenedModePointer);
    }

    /**
     * @param app: game app
     * @param waka: Waka
     * The method draws the Ghost's image to app.
     * It also updates the sodaModePointer and sodaMode of the Ghost.
     */
    public void draw(PApplet app, Waka waka) {
        if (frightened) {
            if (waka.getEnableSodaMode()) {
                waka.setSodaMode(false);
                sodaModePointer = 0;
            }
            app.image(this.frightenedImg,this.x,this.y);
            return;
        }
        if (sodaMode && sodaModePointer!= 300) {
            if ((sodaModePointer/5)%2 == 0) {
                app.image(this.wavy1Img,this.x,this.y);
            } else {
                app.image(this.wavy2Img,this.x,this.y);
            }
            sodaModePointer ++;
            return;
        } else if (sodaModePointer == 300) {
            waka.setSodaMode(false);
            sodaModePointer = 0;
        }
        app.image(this.sprite,this.x,this.y);
        if (debug) {
            if (scatter) {
                if (target.equals("LeftUpCorner"))
                {
                    app.line(0,0,this.x+13,this.y+10);
                } else if (target.equals("RightUpCorner"))
                {
                    app.line(448,0,this.x+13,this.y+10);
                } else if (target.equals("LeftDownCorner"))
                {
                    app.line(0,576,this.x+13,this.y+10);
                } else if (target.equals("RightDownCorner"))
                {
                    app.line(448,576,this.x+13,this.y+10);
                }
                
            } else {
                app.line(wakaX+12,wakaY+12,this.x+13,this.y+10);
            }
        }

    }
    /**
     * Elementary move, if possible, move the ghost to the Left, return true.
     * Otherwise, return false.
     * @param cellMap: list of list of Cells
     * @return boolean
     */
    public boolean toLeft(ArrayList<ArrayList<Cell>> cellMap) {
        if (((cellMap.get((y+4)/16+1).get((x-13+2)/16+1).getMoveOn()
            && cellMap.get((y-11)/16+1).get((x-13+2)/16+1).getMoveOn())
            || (cellMap.get((y+4)/16+1).get((x-28+2)/16+1).getMoveOn()
            && cellMap.get((y-11)/16+1).get((x-28+2)/16+1).getMoveOn()))
            && lastDirection != 2 && this.x > 10) {
                this.x -=speed;
                lastDirection = 1;
                return true;
            }
        return false;
    }

    /**
     * Elementary move, if possible, move the ghost up, return true.
     * Otherwise, return false.
     * @param cellMap: list of list of Cells
     * @return boolean
     */
    public boolean toUp(ArrayList<ArrayList<Cell>> cellMap) {
        if (((cellMap.get((y-27)/16+1).get((x+3+2)/16+1).getMoveOn()
            && cellMap.get((y-27)/16+1).get((x-12+2)/16+1).getMoveOn())
            || (cellMap.get((y-12)/16+1).get((x+3+2)/16+1).getMoveOn()
            && cellMap.get((y-12)/16+1).get((x-12+2)/16+1).getMoveOn()))
            && lastDirection != 4) {
                this.y -= speed;
                lastDirection = 3;
                return true;
            }
        return false;
    }

    /**
     * Elementary move, if possible, move the ghost to the right, return true.
     * Otherwise, return false.
     * @param cellMap: list of list of Cells
     * @return boolean
     */
    public boolean toRight(ArrayList<ArrayList<Cell>> cellMap) {
        if (((cellMap.get((y+4)/16+1).get((x+4+2)/16+1).getMoveOn() 
            && cellMap.get((y-11)/16+1).get((x+4+2)/16+1).getMoveOn()) 
            || (cellMap.get((y+4)/16+1).get((x+19+2)/16+1).getMoveOn()
            && cellMap.get((y-11)/16+1).get((x+19+2)/16+1).getMoveOn()))
            && lastDirection != 1) {
                this.x += speed;
                lastDirection = 2;
                return true;
            }
        return false;
    }

    /**
     * Elementary move, if possible, move the ghost to downwards, return true.
     * Otherwise, return false.
     * @param cellMap: list of list of Cells
     * @return boolean
     */
    public boolean toDown(ArrayList<ArrayList<Cell>> cellMap) {
        if (((cellMap.get((y+5)/16+1).get((x+3+2)/16+1).getMoveOn()
            && cellMap.get((y+5)/16+1).get((x-12+2)/16+1).getMoveOn())
            || (cellMap.get((y+20)/16+1).get((x+3+2)/16+1).getMoveOn()
            && cellMap.get((y+20)/16+1).get((x-12+2)/16+1).getMoveOn()))
            && lastDirection != 3) {
                this.y += speed;
                lastDirection = 4;
                return true;
            } 
            return false;
    }

    /**
     * Getter method for frightened
     * @return boolean
     */
    public boolean getFrightened() {
        return frightened;
    }

    /**
     * method designed to move ghosts when they meet a dead end/trap.
     * Ghosts are allowed to move back.
     * @return lastDirection: latest direction of the Ghost;
     */
    public int goBack() {
        if (lastDirection == 1) {
            this.x += speed;
            lastDirection = 2;
        } else if (lastDirection == 2) {
            this.x -= speed;
            lastDirection = 1;
        } else if (lastDirection == 3) {
            this.y += speed;
            lastDirection = 4;
        } else if (lastDirection == 4) {
            this.y -= speed;
            lastDirection = 3;
        }
        return lastDirection;
    }

    /**
     * methods of move that will be implemented in child classes.
     * This method will be implemented by Ambusher to target 4 grid spaces ahead of Waka.
     */
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, String direction, boolean sodaMode) {};

    /**
     * methods of move that will be implemented in child classes.
     * This method will be implemented by Chaser to chase Waka.
     */
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, boolean sodaMode) {}

    /**
     * methods of move that will be implemented in child classes.
     * This method will be implemented by Whim to chase double the vector from Chaser to 2 grid spaces ahead of 
     * Waka.
     */
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, String direction, int chaserX, int chaserY, boolean sodaMode) {}

    /**
     * method for randomly moving Ghosts when they are in frightened mode.
     */
    public void move(ArrayList<ArrayList<Cell>> cellMap) {
        
        Random randomGenerator = new Random();
        double randomness = randomGenerator.nextDouble();
        if (randomness < 0.25) {
            if (toLeft(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toDown(cellMap)) {
            } else { goBack();}
            return;
        } else if (randomness < 0.5) {
            if (toRight(cellMap)) {
            } else if (toUp(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toDown(cellMap)) {
            } else { goBack();}
            return;
        } else if (randomness < 0.75) {
            if (toLeft(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toRight(cellMap)) {
            } else if (toUp(cellMap)) {
            } else { goBack();}
            return;
        } else if (randomness < 1.0) {
            if (toRight(cellMap)) {
            } else if (toDown(cellMap)) {
            } else if (toLeft(cellMap)) {
            } else if (toUp(cellMap)) {
            } else { goBack();}
            return;          
        }

    }

    /**
     * This method reverses the scatter state of the ghost.
     */
    public void reverseMode() {
        scatter = !scatter;
    }

    /**
     * This method checks if the Waka and Ghosts are touching
     * @param wakaX: x coordinate of Waka in unit of Pixel.
     * @param wakaY: y coordinate of Waka in unit of Pixel.
     * @return boolean: true/false.
     */
    public boolean touch(int wakaX, int wakaY) {
        if ((wakaX > x-10 && wakaX < x+10) && (wakaY > y-10 && wakaY <y+10)) {
            return true;
        }
        return false;
    }

    /**
     * Static method draw all the ghosts in ghosts ArrayList onto the App.
     * @param app: game app
     * @param ghosts: ArrayList pf ghosts
     * @param waka: Waka
     * @param debug: whether debug mode
     */
    public static void ghostsDraw(App app,ArrayList<Ghost> ghosts,Waka waka,boolean debug) {
        updateGhostFrightened(waka);
        for (Ghost g: ghosts) {
            g.setDebug(debug);
            g.draw(app,waka);
        }
    }

    /**
     * this method checks if ghosts are touching with Waka, and returns number of lives lost.
     * @param ghosts: ArrayList of ghosts
     * @param waka: Waka
     * @param app: game app
     * @param lives: number of lives
     * @return lostLives: number of lives lost
     */
    public static int ghostEat(ArrayList<Ghost> ghosts, Waka waka, App app, int lives) {
        boolean eaten = false;
        for (Ghost g: ghosts) {
            if (g.touch(waka.getX(),waka.getY())) {
                if (g.getFrightened()) {
                    ghosts.remove(g);
                    return 0;
                }
                if (lives == 1) {
                    return 1;
                }
                eaten = true;
            }
        }
        if (eaten) {
            app.setup();
            return 1;
        }
        return 0;
    }

    /**
     * Setter method for frightened
     * @param frightened: boolean variable;
     */
    public void setFrightened(boolean frightened) {
        this.frightened = frightened;
    }

    /**
     * This method checks if the ghosts need to change between scatter - chase modes,
     * by checking I,J modePointers.
     * It is also a clock that will pause when ghosts are in frightened mode.
     * @param ghosts: ArrayList of ghosts
     * @param modelengths: specified by the configuration file.
     * @param enableFrightenedMode: boolean variable.
     */
    public static void checkReverse( 
    ArrayList<Ghost> ghosts,JSONArray modelengths, boolean enableFrightenedMode) {
        Ghost.modePointerI++;
        if (enableFrightenedMode) {
            Ghost.modePointerI--;
            Ghost.setIJPointers(Ghost.modePointerI,Ghost.modePointerJ);
            return;
        }
        if (Ghost.modePointerI >= modelengths.getInt(modePointerJ)*60) {
            Ghost.modePointerI = 0;
            Ghost.modePointerJ ++;

            for (Ghost g: ghosts) {
                g.reverseMode();
            }
        }
        if (Ghost.modePointerJ >= modelengths.size()) {
            Ghost.modePointerJ = 0;
        }
    }

    /**
     * Static method that move all the ghosts in once.
     * @param ghosts: ArrayList of ghosts
     * @param cellMap: ArrayList of ArrayList of cells
     * @param waka: Waka
     * @param direction: waka's current direction
     */
    public static void ghostsMove(ArrayList<Ghost> ghosts,ArrayList<ArrayList<Cell>> cellMap, Waka waka, String direction) {
        for (Ghost g: ghosts) {
            boolean frightenedMode = waka.getEnableFrightenedMode();
            if (g.getIdentity() == "Ambusher") {
                g.setFrightened(frightenedMode);
                if (frightenedMode) {
                    g.move(cellMap);
                } else {
                    g.move(cellMap,waka.getX(),waka.getY(),direction,waka.getEnableSodaMode());
                }
            } else if (g.getIdentity() == "Whim") {
                Ghost chaser = null;
                for (int i = 0; i < ghosts.size(); i++) {
                    if (ghosts.get(i).getIdentity() == "Chaser") {
                        chaser = ghosts.get(i);
                        break;
                    }
                }
                if (chaser != null) {
                    g.setFrightened(frightenedMode);
                    if (frightenedMode) {
                        g.move(cellMap,waka.getX(),waka.getY(),false);
                    } else {
                        g.move(cellMap,waka.getX(),waka.getY(),direction, chaser.getX(),chaser.getY(), waka.getEnableSodaMode());
                    }
                } else {
                    g.setFrightened(frightenedMode);
                    if (frightenedMode) {
                        g.move(cellMap);
                    } else {
                        g.move(cellMap,waka.getX(),waka.getY(),waka.getEnableSodaMode());
                    }
                }
            } else {
                g.setFrightened(frightenedMode);
                if (frightenedMode) {
                    g.move(cellMap);
                } else {
                    g.move(cellMap,waka.getX(),waka.getY(),waka.getEnableSodaMode());
                }
            }
        }
    }
    /**
     * Setter method for debug
     * @param debug: boolean variable
     */
    public void setDebug(boolean debug) {
        this.debug = debug;
    }
}
class Ambusher extends Ghost {
    private int targetX;
    private int targetY;
    public int getTargetX() {
        return targetX;
    }
    public int getTargetY() {
        return targetY;
    }
    public  Ambusher(int x, int y, PImage sprite,PImage frightenedImg,PImage wavy1Img,PImage wavy2Img, int speed, int frightenedModeLength) {
        super(x,y,sprite,frightenedImg,wavy1Img, wavy2Img, speed, frightenedModeLength);
    }
    public Ambusher(int x, int y, int speed) {
        super(x,y,speed);
    }
    @Override
    public String getIdentity() {
        return "Ambusher";
    }
    @Override
    public void draw(PApplet app, Waka waka) {
        if (frightened) {
            if (waka.getEnableSodaMode()) {
                waka.setSodaMode(false);
                sodaModePointer = 0;
            }
            app.image(this.frightenedImg,this.x,this.y);
            return;
        }
        if (sodaMode && sodaModePointer!= 300) {
            if ((sodaModePointer/5)%2 == 0) {
                app.image(this.wavy1Img,this.x,this.y);
            } else {
                app.image(this.wavy2Img,this.x,this.y);
            }
            sodaModePointer ++;
            return;
        } else if (sodaModePointer == 300) {
            waka.setSodaMode(false);
            sodaModePointer = 0;
        }
        app.image(this.sprite,this.x,this.y);
        if (debug) {
            if (scatter) {
                if (target.equals("LeftUpCorner"))
                {
                    app.line(0,0,this.x+13,this.y+10);
                } else if (target.equals("RightUpCorner"))
                {
                    app.line(448,0,this.x+13,this.y+10);
                } else if (target.equals("LeftDownCorner"))
                {
                    app.line(0,576,this.x+13,this.y+10);
                } else if (target.equals("RightDownCorner"))
                {
                    app.line(448,576,this.x+13,this.y+10);
                }
                
            } else {
                app.line(targetX+12,targetY+12,this.x+13,this.y+10);
            }
        }
    }
    @Override
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, String direction, boolean sodaMode) {
        this.sodaMode = sodaMode;
        this.wakaX = wakaX;
        this.wakaY = wakaY;
        int closest;
        if (scatter) {
            target = "RightUpCorner";
            closest = generateClosest(448,0);
        } else {
            if (direction == "right") {
                targetX = wakaX + 64;
                targetY = wakaY;
                if (targetX  > 448) {
                    targetX  = 448;
                }
            } else if (direction == "left") {
                targetX  = wakaX - 64;
                targetY = wakaY;
                if (targetX  < 0) {
                    targetX  = 0;
                }
            } else if (direction == "up") {
                targetY = wakaY - 64;
                targetX = wakaX;
                if (targetY < 0) {
                    targetY = 0;
                }

            } else if (direction == "down") {
                targetY = wakaY + 64;
                targetX = wakaX;
                if (targetY > 576) {
                    targetY = 576;
                }
            }
            closest = generateClosest(targetX,targetY);
        }
        moveAccordingToClosest(cellMap,closest);
    }

}

class Chaser extends Ghost {
    public  Chaser(int x, int y, PImage sprite,PImage frightenedImg,PImage wavy1Img,PImage wavy2Img, int speed,int frightenedModeLength) {
        super(x,y,sprite,frightenedImg,wavy1Img, wavy2Img, speed, frightenedModeLength);
    }
    public Chaser(int x, int y, int speed) {
        super(x,y,speed);
    }
    @Override
    public String getIdentity() {
        return "Chaser";
    }
    @Override
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, boolean sodaMode) {
        this.sodaMode = sodaMode;
        this.wakaX = wakaX;
        this.wakaY = wakaY;
        int closest;
        if (scatter) {
            target = "LeftUpCorner";
            closest = generateClosest(0,0);
        } else {
            closest = generateClosest(wakaX,wakaY);
        }
        moveAccordingToClosest(cellMap,closest);

    }
}

class Ignorant extends Ghost {
    private int targetX;
    private int targetY;
    public  Ignorant(int x, int y, PImage sprite,PImage frightenedImg,PImage wavy1Img,PImage wavy2Img, int speed, int frightenedModeLength) {
        super(x,y,sprite,frightenedImg,wavy1Img, wavy2Img, speed, frightenedModeLength);
    }
    public Ignorant(int x, int y, int speed) {
        super(x,y,speed);
    }
    @Override
    public String getIdentity() {
        return "Ignorant";
    }
    @Override
    public void draw(PApplet app, Waka waka) {
        if (frightened) {
            if (waka.getEnableSodaMode()) {
                waka.setSodaMode(false);
                sodaModePointer = 0;
            }
            app.image(this.frightenedImg,this.x,this.y);
            return;
        }
        if (sodaMode && sodaModePointer!= 300) {
            if ((sodaModePointer/5)%2 == 0) {
                app.image(this.wavy1Img,this.x,this.y);
            } else {
                app.image(this.wavy2Img,this.x,this.y);
            }
            sodaModePointer ++;
            return;
        } else if (sodaModePointer == 300) {
            waka.setSodaMode(false);
            sodaModePointer = 0;
        }
        app.image(this.sprite,this.x,this.y);
        if (debug) {
            if (scatter) {
                if (target.equals("LeftUpCorner"))
                {
                    app.line(0,0,this.x+13,this.y+10);
                } else if (target.equals("RightUpCorner"))
                {
                    app.line(448,0,this.x+13,this.y+10);
                } else if (target.equals("LeftDownCorner"))
                {
                    app.line(0,576,this.x+13,this.y+10);
                } else if (target.equals("RightDownCorner"))
                {
                    app.line(448,576,this.x+13,this.y+10);
                }
                
            } else {
                app.line(targetX+12,targetY+12,this.x+13,this.y+10);
            }
        }
    }
    @Override
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, boolean sodaMode) {
        this.sodaMode = sodaMode;
        this.wakaX = wakaX;
        this.wakaY = wakaY;
        int closest;
        if (scatter) {
            target = "LeftDownCorner";
            closest = generateClosest(0,576);
        } else {
            int distance = (wakaX - this.x)*(wakaX-this.x) + (wakaY - this.y)*(wakaY -  this.y);
            targetX = 0;
            targetY = 576;
            if (distance <= 16384) {
                targetX = wakaX;
                targetY = wakaY;
            }
            closest = generateClosest(targetX,targetY);
        }
        moveAccordingToClosest(cellMap,closest);

    }
}

class Whim extends Ghost {
    private int targetX;
    private int targetY;
    public  Whim(int x, int y, PImage sprite,PImage frightenedImg,PImage wavy1Img,PImage wavy2Img, int speed, int frightenedModeLength) {
        super(x,y,sprite,frightenedImg,wavy1Img, wavy2Img, speed, frightenedModeLength);
    }
    public Whim(int x, int y, int speed) {
        super(x,y,speed);
    }
    @Override
    public void draw(PApplet app, Waka waka) {

        if (frightened) {
            if (waka.getEnableSodaMode()) {
                waka.setSodaMode(false);
                sodaModePointer = 0;
            }
            app.image(this.frightenedImg,this.x,this.y);
            return;
        }
        if (sodaMode && sodaModePointer!= 300) {
            if ((sodaModePointer/5)%2 == 0) {
                app.image(this.wavy1Img,this.x,this.y);
            } else {
                app.image(this.wavy2Img,this.x,this.y);
            }
            sodaModePointer ++;
            return;
        } else if (sodaModePointer == 300) {
            waka.setSodaMode(false);
            sodaModePointer = 0;
        }
        app.image(this.sprite,this.x,this.y);
        if (debug) {
            if (scatter) {
                if (target.equals("LeftUpCorner"))
                {
                    app.line(0,0,this.x+13,this.y+10);
                } else if (target.equals("RightUpCorner"))
                {
                    app.line(448,0,this.x+13,this.y+10);
                } else if (target.equals("LeftDownCorner"))
                {
                    app.line(0,576,this.x+13,this.y+10);
                } else if (target.equals("RightDownCorner"))
                {
                    app.line(448,576,this.x+13,this.y+10);
                }
                
            } else {
                app.line(targetX+12,targetY+12,this.x+13,this.y+10);
            }
        }
    }
    @Override
    public String getIdentity() {
        return "Whim";
    }
    @Override
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, boolean sodaMode) {
        this.sodaMode = sodaMode;
        this.wakaX = wakaX;
        this.wakaY = wakaY;
        targetX = wakaX;
        targetY = wakaY;
        int closest;
        if (scatter) {
            target = "RightDownCorner";
            closest = generateClosest(448,576);
        } else {
            closest = generateClosest(targetX,targetY);
        }
        moveAccordingToClosest(cellMap,closest);

    }
    @Override
    public void move(ArrayList<ArrayList<Cell>> cellMap,int wakaX, int wakaY, String direction, int chaserX, int chaserY, boolean sodaMode) {
        this.sodaMode = sodaMode;
        this.wakaX = wakaX;
        this.wakaY = wakaY;
        int closest;
        if (scatter) {
            closest = generateClosest(448,576);
            target = "RightDownCorner";
        } else {
            if (direction == "right") {
                targetX = wakaX*2 + 64 - chaserX;
                targetY = wakaY*2 - chaserY;
            } else if (direction == "left") {
                targetX = wakaX*2 - 64 - chaserX;
                targetY = wakaY*2 - chaserY;
            } else if (direction == "up") {
                targetX = wakaX*2 - chaserX;
                targetY = wakaY*2 - 64 - chaserY;
            } else if (direction == "down") {
                targetX = wakaX*2 - chaserX;
                targetY = wakaY*2 + 64 - chaserY;
            }
            if (targetX > 448) {
                targetX = 448;
            }
            if (targetX < 0) {
                targetX = 0;
            }
            if (targetY > 576) {
                targetY = 576;
            }
            if (targetY < 0) {
                targetY = 0;
            }
            closest = generateClosest(targetX,targetY);
        }
        moveAccordingToClosest(cellMap,closest);
    }

}
